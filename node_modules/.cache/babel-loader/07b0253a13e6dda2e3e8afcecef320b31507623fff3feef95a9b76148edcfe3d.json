{"ast":null,"code":"import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { getAuth } from 'firebase/auth';\nclass PresentationService {\n  // Get a reference to the presentations subcollection for a course\n  getPresentationsCollection(courseId) {\n    return collection(db, 'courses', courseId, 'presentations');\n  }\n\n  // Create a new presentation with unified structure\n  async createPresentation(courseId, title, ownerId) {\n    try {\n      console.log('[PresentationService] Creating presentation:', {\n        courseId,\n        title,\n        ownerId\n      });\n      // Fetch course to get instructorId\n      const courseDoc = await getDoc(doc(db, 'courses', courseId));\n      if (!courseDoc.exists()) throw new Error('Course not found');\n      const instructorId = courseDoc.data().instructorId;\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const docRef = await addDoc(presentationsCol, {\n        title,\n        ownerId,\n        instructorId,\n        // for consistency\n        courseId,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        currentSlideIndex: 0,\n        audienceMode: 'enrolledUsers',\n        // Default mode\n        isLive: false,\n        slides: [] // Initialize empty slides array\n      });\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\n      return docRef;\n    } catch (err) {\n      console.error('[PresentationService] Error creating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Get all presentations for a course\n  async getPresentations(courseId) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? {\n        uid: user.uid,\n        email: user.email\n      } : user);\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\n      const snapshot = await getDocs(q);\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\n      const presentations = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] Presentations fetched:', presentations);\n      return presentations;\n    } catch (err) {\n      console.error('[PresentationService] Error fetching presentations:', err);\n      throw err;\n    }\n  }\n\n  // Get a single presentation with all slides\n  async getPresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Getting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      const snapshot = await getDoc(presentationDoc);\n      if (!snapshot.exists()) {\n        throw new Error('Presentation not found');\n      }\n      const presentation = {\n        id: snapshot.id,\n        ...snapshot.data()\n      };\n      console.log('[PresentationService] Presentation fetched:', presentation);\n      return presentation;\n    } catch (err) {\n      console.error('[PresentationService] Error getting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Update presentation metadata\n  async updatePresentation(courseId, presentationId, updates) {\n    try {\n      console.log('[PresentationService] Updating presentation:', {\n        courseId,\n        presentationId,\n        updates\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        ...updates,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Presentation updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Delete a presentation\n  async deletePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Deleting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await deleteDoc(presentationDoc);\n      console.log('[PresentationService] Presentation deleted successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error deleting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Set a presentation as live\n  async setLivePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Setting live presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const snapshot = await getDocs(presentationsCol);\n      // Set isLive: false for all presentations\n      const batch = [];\n      snapshot.forEach(docSnap => {\n        if (docSnap.id !== presentationId && docSnap.data().isLive) {\n          batch.push(updateDoc(doc(db, 'courses', courseId, 'presentations', docSnap.id), {\n            isLive: false\n          }));\n        }\n      });\n      await Promise.all(batch);\n      // Set isLive: true for the selected presentation\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        isLive: true,\n        updatedAt: serverTimestamp()\n      });\n      // Set livePresentation field on the course document\n      await updateDoc(doc(db, 'courses', courseId), {\n        livePresentation: presentationId\n      });\n      console.log('[PresentationService] Live presentation set successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error setting live presentation:', err);\n      throw err;\n    }\n  }\n\n  // Add a slide to the presentation (subcollection)\n  async addSlide(courseId, presentationId, slideData) {\n    try {\n      console.log('[PresentationService] Adding slide to subcollection:', {\n        courseId,\n        presentationId,\n        slideData\n      });\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\n      // Find max order\n      const slidesSnap = await getDocs(slidesCol);\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => {\n        var _doc$data$order;\n        return Math.max(max, (_doc$data$order = doc.data().order) !== null && _doc$data$order !== void 0 ? _doc$data$order : 0);\n      }, -1);\n      const newSlide = {\n        ...slideData,\n        order: slideData.order !== undefined ? slideData.order : maxOrder + 1,\n        createdAt: Date.now(),\n        updatedAt: Date.now()\n      };\n      const docRef = await addDoc(slidesCol, newSlide);\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\n      return {\n        id: docRef.id,\n        ...newSlide\n      };\n    } catch (err) {\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Update a specific slide (subcollection)\n  async updateSlide(courseId, presentationId, slideId, updates) {\n    try {\n      console.log('[PresentationService] Updating slide in subcollection:', {\n        courseId,\n        presentationId,\n        slideId,\n        updates\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await updateDoc(slideDoc, {\n        ...updates,\n        updatedAt: Date.now()\n      });\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Delete a slide (subcollection)\n  async deleteSlide(courseId, presentationId, slideId) {\n    try {\n      console.log('[PresentationService] Deleting slide from subcollection:', {\n        courseId,\n        presentationId,\n        slideId\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await deleteDoc(slideDoc);\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Add a comment to a slide\n  async addComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      console.log('[PresentationService] Adding comment:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        commentData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: commentData.username,\n        userId: commentData.userId,\n        text: commentData.text,\n        timestamp: serverTimestamp(),\n        likes: 0,\n        likedBy: [],\n        includedInGroups: []\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].comments.push(newComment);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding comment:', err);\n      throw err;\n    }\n  }\n\n  // Add a response to a slide (for poll slides)\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      console.log('[PresentationService] Adding response:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        responseData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: responseData.username,\n        userId: responseData.userId,\n        answer: responseData.answer,\n        text: responseData.text,\n        timestamp: serverTimestamp(),\n        isCorrect: responseData.isCorrect || false\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].responses.push(newResponse);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding response:', err);\n      throw err;\n    }\n  }\n\n  // Create a group for comments\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      console.log('[PresentationService] Creating group:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        groupData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        label: groupData.label,\n        comments: groupData.comments || [],\n        likes: 0,\n        likedBy: [],\n        location: groupData.location || {\n          x: 0,\n          y: 0\n        },\n        createdAt: serverTimestamp()\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].groups.push(newGroup);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error creating group:', err);\n      throw err;\n    }\n  }\n\n  // Update current slide index for live presentations\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\n    try {\n      console.log('[PresentationService] Updating current slide index:', {\n        courseId,\n        presentationId,\n        slideIndex\n      });\n      await this.updatePresentation(courseId, presentationId, {\n        currentSlideIndex: slideIndex\n      });\n      console.log('[PresentationService] Current slide index updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating current slide index:', err);\n      throw err;\n    }\n  }\n\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\n\n  // Add or update a student's response doc for a presentation\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...responseData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].responses.push(newResponse);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student response added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newResponse\n      });\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student response:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's comment for a slide\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...commentData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].comments.push(newComment);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student comment added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newComment\n      });\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student comment:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's group for a slide\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...groupData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].groups.push(newGroup);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student group added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newGroup\n      });\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student group:', err);\n      throw err;\n    }\n  }\n\n  // Get a student's response doc\n  async getStudentResponse(courseId, presentationId, userId) {\n    try {\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      const docSnap = await getDoc(responseDocRef);\n      if (!docSnap.exists()) return null;\n      return docSnap.data();\n    } catch (err) {\n      console.error('[PresentationService] Error getting student response:', err);\n      throw err;\n    }\n  }\n\n  // Get all student responses for a presentation (instructor only)\n  async getAllResponses(courseId, presentationId) {\n    try {\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\n      const snapshot = await getDocs(responsesCol);\n      const allResponses = snapshot.docs.map(doc => ({\n        userId: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] All student responses fetched:', allResponses);\n      return allResponses;\n    } catch (err) {\n      console.error('[PresentationService] Error getting all responses:', err);\n      throw err;\n    }\n  }\n}\nexport default new PresentationService();","map":{"version":3,"names":["collection","addDoc","getDocs","query","orderBy","serverTimestamp","doc","deleteDoc","updateDoc","getDoc","setDoc","db","getAuth","PresentationService","getPresentationsCollection","courseId","createPresentation","title","ownerId","console","log","courseDoc","exists","Error","instructorId","data","presentationsCol","docRef","createdAt","updatedAt","currentSlideIndex","audienceMode","isLive","slides","id","err","error","getPresentations","auth","user","currentUser","uid","email","q","snapshot","size","presentations","docs","map","getPresentation","presentationId","presentationDoc","presentation","updatePresentation","updates","deletePresentation","setLivePresentation","batch","forEach","docSnap","push","Promise","all","livePresentation","addSlide","slideData","slidesCol","slidesSnap","maxOrder","reduce","max","_doc$data$order","Math","order","newSlide","undefined","Date","now","updateSlide","slideId","slideDoc","deleteSlide","addComment","slideIndex","commentData","length","newComment","random","toString","substr","username","userId","text","timestamp","likes","likedBy","includedInGroups","updatedSlides","comments","addResponse","responseData","newResponse","answer","isCorrect","responses","createGroup","groupData","newGroup","label","location","x","y","groups","updateCurrentSlideIndex","addStudentResponse","responseDocRef","addStudentComment","addStudentGroup","getStudentResponse","getAllResponses","responsesCol","allResponses"],"sources":["C:/Users/aanime/commeff3/src/services/PresentationService.js"],"sourcesContent":["import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { db } from '../firebase/config';\r\nimport { getAuth } from 'firebase/auth';\r\n\r\nclass PresentationService {\r\n  // Get a reference to the presentations subcollection for a course\r\n  getPresentationsCollection(courseId) {\r\n    return collection(db, 'courses', courseId, 'presentations');\r\n  }\r\n\r\n  // Create a new presentation with unified structure\r\n  async createPresentation(courseId, title, ownerId) {\r\n    try {\r\n      console.log('[PresentationService] Creating presentation:', { courseId, title, ownerId });\r\n      // Fetch course to get instructorId\r\n      const courseDoc = await getDoc(doc(db, 'courses', courseId));\r\n      if (!courseDoc.exists()) throw new Error('Course not found');\r\n      const instructorId = courseDoc.data().instructorId;\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const docRef = await addDoc(presentationsCol, {\r\n        title,\r\n        ownerId,\r\n        instructorId, // for consistency\r\n        courseId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        currentSlideIndex: 0,\r\n        audienceMode: 'enrolledUsers', // Default mode\r\n        isLive: false,\r\n        slides: [] // Initialize empty slides array\r\n      });\r\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\r\n      return docRef;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all presentations for a course\r\n  async getPresentations(courseId) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? { uid: user.uid, email: user.email } : user);\r\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\r\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\r\n      const snapshot = await getDocs(q);\r\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\r\n      const presentations = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      console.log('[PresentationService] Presentations fetched:', presentations);\r\n      return presentations;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error fetching presentations:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a single presentation with all slides\r\n  async getPresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Getting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      const snapshot = await getDoc(presentationDoc);\r\n      \r\n      if (!snapshot.exists()) {\r\n        throw new Error('Presentation not found');\r\n      }\r\n      \r\n      const presentation = {\r\n        id: snapshot.id,\r\n        ...snapshot.data()\r\n      };\r\n      \r\n      console.log('[PresentationService] Presentation fetched:', presentation);\r\n      return presentation;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update presentation metadata\r\n  async updatePresentation(courseId, presentationId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating presentation:', { courseId, presentationId, updates });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        ...updates,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Presentation updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a presentation\r\n  async deletePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await deleteDoc(presentationDoc);\r\n      console.log('[PresentationService] Presentation deleted successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Set a presentation as live\r\n  async setLivePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Setting live presentation:', { courseId, presentationId });\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const snapshot = await getDocs(presentationsCol);\r\n      // Set isLive: false for all presentations\r\n      const batch = [];\r\n      snapshot.forEach(docSnap => {\r\n        if (docSnap.id !== presentationId && docSnap.data().isLive) {\r\n          batch.push(updateDoc(doc(db, 'courses', courseId, 'presentations', docSnap.id), { isLive: false }));\r\n        }\r\n      });\r\n      await Promise.all(batch);\r\n      // Set isLive: true for the selected presentation\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        isLive: true,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      // Set livePresentation field on the course document\r\n      await updateDoc(doc(db, 'courses', courseId), { livePresentation: presentationId });\r\n      console.log('[PresentationService] Live presentation set successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error setting live presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a slide to the presentation (subcollection)\r\n  async addSlide(courseId, presentationId, slideData) {\r\n    try {\r\n      console.log('[PresentationService] Adding slide to subcollection:', { courseId, presentationId, slideData });\r\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\r\n      // Find max order\r\n      const slidesSnap = await getDocs(slidesCol);\r\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => Math.max(max, doc.data().order ?? 0), -1);\r\n      const newSlide = {\r\n        ...slideData,\r\n        order: (slideData.order !== undefined ? slideData.order : maxOrder + 1),\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n      };\r\n      const docRef = await addDoc(slidesCol, newSlide);\r\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\r\n      return { id: docRef.id, ...newSlide };\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update a specific slide (subcollection)\r\n  async updateSlide(courseId, presentationId, slideId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating slide in subcollection:', { courseId, presentationId, slideId, updates });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await updateDoc(slideDoc, { ...updates, updatedAt: Date.now() });\r\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a slide (subcollection)\r\n  async deleteSlide(courseId, presentationId, slideId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting slide from subcollection:', { courseId, presentationId, slideId });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await deleteDoc(slideDoc);\r\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a comment to a slide\r\n  async addComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      console.log('[PresentationService] Adding comment:', { courseId, presentationId, slideIndex, commentData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: commentData.username,\r\n        userId: commentData.userId,\r\n        text: commentData.text,\r\n        timestamp: serverTimestamp(),\r\n        likes: 0,\r\n        likedBy: [],\r\n        includedInGroups: []\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].comments.push(newComment);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a response to a slide (for poll slides)\r\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      console.log('[PresentationService] Adding response:', { courseId, presentationId, slideIndex, responseData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: responseData.username,\r\n        userId: responseData.userId,\r\n        answer: responseData.answer,\r\n        text: responseData.text,\r\n        timestamp: serverTimestamp(),\r\n        isCorrect: responseData.isCorrect || false\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].responses.push(newResponse);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Create a group for comments\r\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      console.log('[PresentationService] Creating group:', { courseId, presentationId, slideIndex, groupData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        label: groupData.label,\r\n        comments: groupData.comments || [],\r\n        likes: 0,\r\n        likedBy: [],\r\n        location: groupData.location || { x: 0, y: 0 },\r\n        createdAt: serverTimestamp()\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].groups.push(newGroup);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update current slide index for live presentations\r\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\r\n    try {\r\n      console.log('[PresentationService] Updating current slide index:', { courseId, presentationId, slideIndex });\r\n      await this.updatePresentation(courseId, presentationId, {\r\n        currentSlideIndex: slideIndex\r\n      });\r\n      console.log('[PresentationService] Current slide index updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating current slide index:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\r\n\r\n  // Add or update a student's response doc for a presentation\r\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...responseData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].responses.push(newResponse);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student response added:', { courseId, presentationId, slideIndex, userId, newResponse });\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's comment for a slide\r\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...commentData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].comments.push(newComment);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student comment added:', { courseId, presentationId, slideIndex, userId, newComment });\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's group for a slide\r\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...groupData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].groups.push(newGroup);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student group added:', { courseId, presentationId, slideIndex, userId, newGroup });\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a student's response doc\r\n  async getStudentResponse(courseId, presentationId, userId) {\r\n    try {\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      const docSnap = await getDoc(responseDocRef);\r\n      if (!docSnap.exists()) return null;\r\n      return docSnap.data();\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all student responses for a presentation (instructor only)\r\n  async getAllResponses(courseId, presentationId) {\r\n    try {\r\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\r\n      const snapshot = await getDocs(responsesCol);\r\n      const allResponses = snapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));\r\n      console.log('[PresentationService] All student responses fetched:', allResponses);\r\n      return allResponses;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting all responses:', err);\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new PresentationService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}