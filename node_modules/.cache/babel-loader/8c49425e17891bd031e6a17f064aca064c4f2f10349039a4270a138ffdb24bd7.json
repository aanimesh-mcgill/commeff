{"ast":null,"code":"import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { getAuth } from 'firebase/auth';\nclass PresentationService {\n  // Get a reference to the presentations subcollection for a course\n  getPresentationsCollection(courseId) {\n    return collection(db, 'courses', courseId, 'presentations');\n  }\n\n  // Create a new presentation with unified structure\n  async createPresentation(courseId, title, ownerId) {\n    try {\n      console.log('[PresentationService] Creating presentation:', {\n        courseId,\n        title,\n        ownerId\n      });\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const docRef = await addDoc(presentationsCol, {\n        title,\n        ownerId,\n        courseId,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        currentSlideIndex: 0,\n        audienceMode: 'enrolledUsers',\n        // Default mode\n        isLive: false,\n        slides: [] // Initialize empty slides array\n      });\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\n      return docRef;\n    } catch (err) {\n      console.error('[PresentationService] Error creating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Get all presentations for a course\n  async getPresentations(courseId) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? {\n        uid: user.uid,\n        email: user.email\n      } : user);\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\n      const snapshot = await getDocs(q);\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\n      const presentations = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] Presentations fetched:', presentations);\n      return presentations;\n    } catch (err) {\n      console.error('[PresentationService] Error fetching presentations:', err);\n      throw err;\n    }\n  }\n\n  // Get a single presentation with all slides\n  async getPresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Getting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      const snapshot = await getDoc(presentationDoc);\n      if (!snapshot.exists()) {\n        throw new Error('Presentation not found');\n      }\n      const presentation = {\n        id: snapshot.id,\n        ...snapshot.data()\n      };\n      console.log('[PresentationService] Presentation fetched:', presentation);\n      return presentation;\n    } catch (err) {\n      console.error('[PresentationService] Error getting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Update presentation metadata\n  async updatePresentation(courseId, presentationId, updates) {\n    try {\n      console.log('[PresentationService] Updating presentation:', {\n        courseId,\n        presentationId,\n        updates\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        ...updates,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Presentation updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Delete a presentation\n  async deletePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Deleting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await deleteDoc(presentationDoc);\n      console.log('[PresentationService] Presentation deleted successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error deleting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Set a presentation as live\n  async setLivePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Setting live presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        isLive: true,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Live presentation set successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error setting live presentation:', err);\n      throw err;\n    }\n  }\n\n  // Add a slide to the presentation\n  async addSlide(courseId, presentationId, slideData) {\n    try {\n      console.log('[PresentationService] Adding slide:', {\n        courseId,\n        presentationId,\n        slideData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      const newSlide = {\n        id: `slide_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        order: presentation.slides.length,\n        title: slideData.title || 'Untitled Slide',\n        type: slideData.type || 'content',\n        content: slideData.content || {},\n        responses: [],\n        comments: [],\n        groups: [],\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp()\n      };\n      const updatedSlides = [...presentation.slides, newSlide];\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Slide added successfully:', newSlide.id);\n      return newSlide;\n    } catch (err) {\n      console.error('[PresentationService] Error adding slide:', err);\n      throw err;\n    }\n  }\n\n  // Update a specific slide\n  async updateSlide(courseId, presentationId, slideIndex, updates) {\n    try {\n      console.log('[PresentationService] Updating slide:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        updates\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex] = {\n        ...updatedSlides[slideIndex],\n        ...updates,\n        updatedAt: serverTimestamp()\n      };\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Slide updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating slide:', err);\n      throw err;\n    }\n  }\n\n  // Delete a slide\n  async deleteSlide(courseId, presentationId, slideIndex) {\n    try {\n      console.log('[PresentationService] Deleting slide:', {\n        courseId,\n        presentationId,\n        slideIndex\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const updatedSlides = presentation.slides.filter((_, index) => index !== slideIndex);\n\n      // Reorder remaining slides\n      updatedSlides.forEach((slide, index) => {\n        slide.order = index;\n      });\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Slide deleted successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error deleting slide:', err);\n      throw err;\n    }\n  }\n\n  // Add a comment to a slide\n  async addComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      console.log('[PresentationService] Adding comment:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        commentData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: commentData.username,\n        userId: commentData.userId,\n        text: commentData.text,\n        timestamp: serverTimestamp(),\n        likes: 0,\n        likedBy: [],\n        includedInGroups: []\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].comments.push(newComment);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding comment:', err);\n      throw err;\n    }\n  }\n\n  // Add a response to a slide (for poll slides)\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      console.log('[PresentationService] Adding response:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        responseData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: responseData.username,\n        userId: responseData.userId,\n        answer: responseData.answer,\n        text: responseData.text,\n        timestamp: serverTimestamp(),\n        isCorrect: responseData.isCorrect || false\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].responses.push(newResponse);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding response:', err);\n      throw err;\n    }\n  }\n\n  // Create a group for comments\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      console.log('[PresentationService] Creating group:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        groupData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        label: groupData.label,\n        comments: groupData.comments || [],\n        likes: 0,\n        likedBy: [],\n        location: groupData.location || {\n          x: 0,\n          y: 0\n        },\n        createdAt: serverTimestamp()\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].groups.push(newGroup);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error creating group:', err);\n      throw err;\n    }\n  }\n\n  // Update current slide index for live presentations\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\n    try {\n      console.log('[PresentationService] Updating current slide index:', {\n        courseId,\n        presentationId,\n        slideIndex\n      });\n      await this.updatePresentation(courseId, presentationId, {\n        currentSlideIndex: slideIndex\n      });\n      console.log('[PresentationService] Current slide index updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating current slide index:', err);\n      throw err;\n    }\n  }\n\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\n\n  // Add or update a student's response doc for a presentation\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...responseData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].responses.push(newResponse);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student response added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newResponse\n      });\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student response:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's comment for a slide\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...commentData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].comments.push(newComment);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student comment added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newComment\n      });\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student comment:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's group for a slide\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...groupData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].groups.push(newGroup);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student group added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newGroup\n      });\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student group:', err);\n      throw err;\n    }\n  }\n\n  // Get a student's response doc\n  async getStudentResponse(courseId, presentationId, userId) {\n    try {\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      const docSnap = await getDoc(responseDocRef);\n      if (!docSnap.exists()) return null;\n      return docSnap.data();\n    } catch (err) {\n      console.error('[PresentationService] Error getting student response:', err);\n      throw err;\n    }\n  }\n\n  // Get all student responses for a presentation (instructor only)\n  async getAllResponses(courseId, presentationId) {\n    try {\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\n      const snapshot = await getDocs(responsesCol);\n      const allResponses = snapshot.docs.map(doc => ({\n        userId: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] All student responses fetched:', allResponses);\n      return allResponses;\n    } catch (err) {\n      console.error('[PresentationService] Error getting all responses:', err);\n      throw err;\n    }\n  }\n}\nexport default new PresentationService();","map":{"version":3,"names":["collection","addDoc","getDocs","query","orderBy","serverTimestamp","doc","deleteDoc","updateDoc","getDoc","setDoc","db","getAuth","PresentationService","getPresentationsCollection","courseId","createPresentation","title","ownerId","console","log","presentationsCol","docRef","createdAt","updatedAt","currentSlideIndex","audienceMode","isLive","slides","id","err","error","getPresentations","auth","user","currentUser","uid","email","q","snapshot","size","presentations","docs","map","data","getPresentation","presentationId","presentationDoc","exists","Error","presentation","updatePresentation","updates","deletePresentation","setLivePresentation","addSlide","slideData","newSlide","Date","now","Math","random","toString","substr","order","length","type","content","responses","comments","groups","updatedSlides","updateSlide","slideIndex","deleteSlide","filter","_","index","forEach","slide","addComment","commentData","newComment","username","userId","text","timestamp","likes","likedBy","includedInGroups","push","addResponse","responseData","newResponse","answer","isCorrect","createGroup","groupData","newGroup","label","location","x","y","updateCurrentSlideIndex","addStudentResponse","responseDocRef","docSnap","addStudentComment","addStudentGroup","getStudentResponse","getAllResponses","responsesCol","allResponses"],"sources":["C:/Users/aanime/commeff3/src/services/PresentationService.js"],"sourcesContent":["import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { db } from '../firebase/config';\r\nimport { getAuth } from 'firebase/auth';\r\n\r\nclass PresentationService {\r\n  // Get a reference to the presentations subcollection for a course\r\n  getPresentationsCollection(courseId) {\r\n    return collection(db, 'courses', courseId, 'presentations');\r\n  }\r\n\r\n  // Create a new presentation with unified structure\r\n  async createPresentation(courseId, title, ownerId) {\r\n    try {\r\n      console.log('[PresentationService] Creating presentation:', { courseId, title, ownerId });\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const docRef = await addDoc(presentationsCol, {\r\n        title,\r\n        ownerId,\r\n        courseId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        currentSlideIndex: 0,\r\n        audienceMode: 'enrolledUsers', // Default mode\r\n        isLive: false,\r\n        slides: [] // Initialize empty slides array\r\n      });\r\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\r\n      return docRef;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all presentations for a course\r\n  async getPresentations(courseId) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? { uid: user.uid, email: user.email } : user);\r\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\r\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\r\n      const snapshot = await getDocs(q);\r\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\r\n      const presentations = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      console.log('[PresentationService] Presentations fetched:', presentations);\r\n      return presentations;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error fetching presentations:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a single presentation with all slides\r\n  async getPresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Getting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      const snapshot = await getDoc(presentationDoc);\r\n      \r\n      if (!snapshot.exists()) {\r\n        throw new Error('Presentation not found');\r\n      }\r\n      \r\n      const presentation = {\r\n        id: snapshot.id,\r\n        ...snapshot.data()\r\n      };\r\n      \r\n      console.log('[PresentationService] Presentation fetched:', presentation);\r\n      return presentation;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update presentation metadata\r\n  async updatePresentation(courseId, presentationId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating presentation:', { courseId, presentationId, updates });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        ...updates,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Presentation updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a presentation\r\n  async deletePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await deleteDoc(presentationDoc);\r\n      console.log('[PresentationService] Presentation deleted successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Set a presentation as live\r\n  async setLivePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Setting live presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        isLive: true,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Live presentation set successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error setting live presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a slide to the presentation\r\n  async addSlide(courseId, presentationId, slideData) {\r\n    try {\r\n      console.log('[PresentationService] Adding slide:', { courseId, presentationId, slideData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      const newSlide = {\r\n        id: `slide_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        order: presentation.slides.length,\r\n        title: slideData.title || 'Untitled Slide',\r\n        type: slideData.type || 'content',\r\n        content: slideData.content || {},\r\n        responses: [],\r\n        comments: [],\r\n        groups: [],\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp()\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides, newSlide];\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Slide added successfully:', newSlide.id);\r\n      return newSlide;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding slide:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update a specific slide\r\n  async updateSlide(courseId, presentationId, slideIndex, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating slide:', { courseId, presentationId, slideIndex, updates });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex] = {\r\n        ...updatedSlides[slideIndex],\r\n        ...updates,\r\n        updatedAt: serverTimestamp()\r\n      };\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Slide updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating slide:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a slide\r\n  async deleteSlide(courseId, presentationId, slideIndex) {\r\n    try {\r\n      console.log('[PresentationService] Deleting slide:', { courseId, presentationId, slideIndex });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const updatedSlides = presentation.slides.filter((_, index) => index !== slideIndex);\r\n      \r\n      // Reorder remaining slides\r\n      updatedSlides.forEach((slide, index) => {\r\n        slide.order = index;\r\n      });\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Slide deleted successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting slide:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a comment to a slide\r\n  async addComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      console.log('[PresentationService] Adding comment:', { courseId, presentationId, slideIndex, commentData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: commentData.username,\r\n        userId: commentData.userId,\r\n        text: commentData.text,\r\n        timestamp: serverTimestamp(),\r\n        likes: 0,\r\n        likedBy: [],\r\n        includedInGroups: []\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].comments.push(newComment);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a response to a slide (for poll slides)\r\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      console.log('[PresentationService] Adding response:', { courseId, presentationId, slideIndex, responseData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: responseData.username,\r\n        userId: responseData.userId,\r\n        answer: responseData.answer,\r\n        text: responseData.text,\r\n        timestamp: serverTimestamp(),\r\n        isCorrect: responseData.isCorrect || false\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].responses.push(newResponse);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Create a group for comments\r\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      console.log('[PresentationService] Creating group:', { courseId, presentationId, slideIndex, groupData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        label: groupData.label,\r\n        comments: groupData.comments || [],\r\n        likes: 0,\r\n        likedBy: [],\r\n        location: groupData.location || { x: 0, y: 0 },\r\n        createdAt: serverTimestamp()\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].groups.push(newGroup);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update current slide index for live presentations\r\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\r\n    try {\r\n      console.log('[PresentationService] Updating current slide index:', { courseId, presentationId, slideIndex });\r\n      await this.updatePresentation(courseId, presentationId, {\r\n        currentSlideIndex: slideIndex\r\n      });\r\n      console.log('[PresentationService] Current slide index updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating current slide index:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\r\n\r\n  // Add or update a student's response doc for a presentation\r\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...responseData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].responses.push(newResponse);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student response added:', { courseId, presentationId, slideIndex, userId, newResponse });\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's comment for a slide\r\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...commentData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].comments.push(newComment);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student comment added:', { courseId, presentationId, slideIndex, userId, newComment });\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's group for a slide\r\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...groupData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].groups.push(newGroup);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student group added:', { courseId, presentationId, slideIndex, userId, newGroup });\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a student's response doc\r\n  async getStudentResponse(courseId, presentationId, userId) {\r\n    try {\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      const docSnap = await getDoc(responseDocRef);\r\n      if (!docSnap.exists()) return null;\r\n      return docSnap.data();\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all student responses for a presentation (instructor only)\r\n  async getAllResponses(courseId, presentationId) {\r\n    try {\r\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\r\n      const snapshot = await getDocs(responsesCol);\r\n      const allResponses = snapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));\r\n      console.log('[PresentationService] All student responses fetched:', allResponses);\r\n      return allResponses;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting all responses:', err);\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new PresentationService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}