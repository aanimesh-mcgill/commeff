{"ast":null,"code":"import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { getAuth } from 'firebase/auth';\nclass PresentationService {\n  // Get a reference to the presentations subcollection for a course\n  getPresentationsCollection(courseId) {\n    return collection(db, 'courses', courseId, 'presentations');\n  }\n\n  // Create a new presentation with unified structure\n  async createPresentation(courseId, title, ownerId) {\n    try {\n      console.log('[PresentationService] Creating presentation:', {\n        courseId,\n        title,\n        ownerId\n      });\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const docRef = await addDoc(presentationsCol, {\n        title,\n        ownerId,\n        courseId,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        currentSlideIndex: 0,\n        audienceMode: 'enrolledUsers',\n        // Default mode\n        isLive: false,\n        slides: [] // Initialize empty slides array\n      });\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\n      return docRef;\n    } catch (err) {\n      console.error('[PresentationService] Error creating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Get all presentations for a course\n  async getPresentations(courseId) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? {\n        uid: user.uid,\n        email: user.email\n      } : user);\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\n      const snapshot = await getDocs(q);\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\n      const presentations = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] Presentations fetched:', presentations);\n      return presentations;\n    } catch (err) {\n      console.error('[PresentationService] Error fetching presentations:', err);\n      throw err;\n    }\n  }\n\n  // Get a single presentation with all slides\n  async getPresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Getting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      const snapshot = await getDoc(presentationDoc);\n      if (!snapshot.exists()) {\n        throw new Error('Presentation not found');\n      }\n      const presentation = {\n        id: snapshot.id,\n        ...snapshot.data()\n      };\n      console.log('[PresentationService] Presentation fetched:', presentation);\n      return presentation;\n    } catch (err) {\n      console.error('[PresentationService] Error getting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Update presentation metadata\n  async updatePresentation(courseId, presentationId, updates) {\n    try {\n      console.log('[PresentationService] Updating presentation:', {\n        courseId,\n        presentationId,\n        updates\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        ...updates,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Presentation updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Delete a presentation\n  async deletePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Deleting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await deleteDoc(presentationDoc);\n      console.log('[PresentationService] Presentation deleted successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error deleting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Set a presentation as live\n  async setLivePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Setting live presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        isLive: true,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Live presentation set successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error setting live presentation:', err);\n      throw err;\n    }\n  }\n\n  // Add a slide to the presentation (subcollection)\n  async addSlide(courseId, presentationId, slideData) {\n    try {\n      console.log('[PresentationService] Adding slide to subcollection:', {\n        courseId,\n        presentationId,\n        slideData\n      });\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\n      // Find max order\n      const slidesSnap = await getDocs(slidesCol);\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => {\n        var _doc$data$order;\n        return Math.max(max, (_doc$data$order = doc.data().order) !== null && _doc$data$order !== void 0 ? _doc$data$order : 0);\n      }, -1);\n      const newSlide = {\n        ...slideData,\n        order: slideData.order !== undefined ? slideData.order : maxOrder + 1,\n        createdAt: Date.now(),\n        updatedAt: Date.now()\n      };\n      const docRef = await addDoc(slidesCol, newSlide);\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\n      return {\n        id: docRef.id,\n        ...newSlide\n      };\n    } catch (err) {\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Update a specific slide (subcollection)\n  async updateSlide(courseId, presentationId, slideId, updates) {\n    try {\n      console.log('[PresentationService] Updating slide in subcollection:', {\n        courseId,\n        presentationId,\n        slideId,\n        updates\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await updateDoc(slideDoc, {\n        ...updates,\n        updatedAt: Date.now()\n      });\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Delete a slide (subcollection)\n  async deleteSlide(courseId, presentationId, slideId) {\n    try {\n      console.log('[PresentationService] Deleting slide from subcollection:', {\n        courseId,\n        presentationId,\n        slideId\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await deleteDoc(slideDoc);\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Add a comment to a slide\n  async addComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      console.log('[PresentationService] Adding comment:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        commentData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: commentData.username,\n        userId: commentData.userId,\n        text: commentData.text,\n        timestamp: serverTimestamp(),\n        likes: 0,\n        likedBy: [],\n        includedInGroups: []\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].comments.push(newComment);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding comment:', err);\n      throw err;\n    }\n  }\n\n  // Add a response to a slide (for poll slides)\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      console.log('[PresentationService] Adding response:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        responseData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: responseData.username,\n        userId: responseData.userId,\n        answer: responseData.answer,\n        text: responseData.text,\n        timestamp: serverTimestamp(),\n        isCorrect: responseData.isCorrect || false\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].responses.push(newResponse);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding response:', err);\n      throw err;\n    }\n  }\n\n  // Create a group for comments\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      console.log('[PresentationService] Creating group:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        groupData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        label: groupData.label,\n        comments: groupData.comments || [],\n        likes: 0,\n        likedBy: [],\n        location: groupData.location || {\n          x: 0,\n          y: 0\n        },\n        createdAt: serverTimestamp()\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].groups.push(newGroup);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error creating group:', err);\n      throw err;\n    }\n  }\n\n  // Update current slide index for live presentations\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\n    try {\n      console.log('[PresentationService] Updating current slide index:', {\n        courseId,\n        presentationId,\n        slideIndex\n      });\n      await this.updatePresentation(courseId, presentationId, {\n        currentSlideIndex: slideIndex\n      });\n      console.log('[PresentationService] Current slide index updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating current slide index:', err);\n      throw err;\n    }\n  }\n\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\n\n  // Add or update a student's response doc for a presentation\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...responseData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].responses.push(newResponse);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student response added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newResponse\n      });\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student response:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's comment for a slide\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...commentData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].comments.push(newComment);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student comment added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newComment\n      });\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student comment:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's group for a slide\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...groupData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].groups.push(newGroup);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student group added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newGroup\n      });\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student group:', err);\n      throw err;\n    }\n  }\n\n  // Get a student's response doc\n  async getStudentResponse(courseId, presentationId, userId) {\n    try {\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      const docSnap = await getDoc(responseDocRef);\n      if (!docSnap.exists()) return null;\n      return docSnap.data();\n    } catch (err) {\n      console.error('[PresentationService] Error getting student response:', err);\n      throw err;\n    }\n  }\n\n  // Get all student responses for a presentation (instructor only)\n  async getAllResponses(courseId, presentationId) {\n    try {\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\n      const snapshot = await getDocs(responsesCol);\n      const allResponses = snapshot.docs.map(doc => ({\n        userId: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] All student responses fetched:', allResponses);\n      return allResponses;\n    } catch (err) {\n      console.error('[PresentationService] Error getting all responses:', err);\n      throw err;\n    }\n  }\n}\nexport default new PresentationService();","map":{"version":3,"names":["collection","addDoc","getDocs","query","orderBy","serverTimestamp","doc","deleteDoc","updateDoc","getDoc","setDoc","db","getAuth","PresentationService","getPresentationsCollection","courseId","createPresentation","title","ownerId","console","log","presentationsCol","docRef","createdAt","updatedAt","currentSlideIndex","audienceMode","isLive","slides","id","err","error","getPresentations","auth","user","currentUser","uid","email","q","snapshot","size","presentations","docs","map","data","getPresentation","presentationId","presentationDoc","exists","Error","presentation","updatePresentation","updates","deletePresentation","setLivePresentation","addSlide","slideData","slidesCol","slidesSnap","maxOrder","reduce","max","_doc$data$order","Math","order","newSlide","undefined","Date","now","updateSlide","slideId","slideDoc","deleteSlide","addComment","slideIndex","commentData","length","newComment","random","toString","substr","username","userId","text","timestamp","likes","likedBy","includedInGroups","updatedSlides","comments","push","addResponse","responseData","newResponse","answer","isCorrect","responses","createGroup","groupData","newGroup","label","location","x","y","groups","updateCurrentSlideIndex","addStudentResponse","responseDocRef","docSnap","addStudentComment","addStudentGroup","getStudentResponse","getAllResponses","responsesCol","allResponses"],"sources":["C:/Users/aanime/commeff3/src/services/PresentationService.js"],"sourcesContent":["import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { db } from '../firebase/config';\r\nimport { getAuth } from 'firebase/auth';\r\n\r\nclass PresentationService {\r\n  // Get a reference to the presentations subcollection for a course\r\n  getPresentationsCollection(courseId) {\r\n    return collection(db, 'courses', courseId, 'presentations');\r\n  }\r\n\r\n  // Create a new presentation with unified structure\r\n  async createPresentation(courseId, title, ownerId) {\r\n    try {\r\n      console.log('[PresentationService] Creating presentation:', { courseId, title, ownerId });\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const docRef = await addDoc(presentationsCol, {\r\n        title,\r\n        ownerId,\r\n        courseId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        currentSlideIndex: 0,\r\n        audienceMode: 'enrolledUsers', // Default mode\r\n        isLive: false,\r\n        slides: [] // Initialize empty slides array\r\n      });\r\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\r\n      return docRef;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all presentations for a course\r\n  async getPresentations(courseId) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? { uid: user.uid, email: user.email } : user);\r\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\r\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\r\n      const snapshot = await getDocs(q);\r\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\r\n      const presentations = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      console.log('[PresentationService] Presentations fetched:', presentations);\r\n      return presentations;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error fetching presentations:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a single presentation with all slides\r\n  async getPresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Getting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      const snapshot = await getDoc(presentationDoc);\r\n      \r\n      if (!snapshot.exists()) {\r\n        throw new Error('Presentation not found');\r\n      }\r\n      \r\n      const presentation = {\r\n        id: snapshot.id,\r\n        ...snapshot.data()\r\n      };\r\n      \r\n      console.log('[PresentationService] Presentation fetched:', presentation);\r\n      return presentation;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update presentation metadata\r\n  async updatePresentation(courseId, presentationId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating presentation:', { courseId, presentationId, updates });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        ...updates,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Presentation updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a presentation\r\n  async deletePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await deleteDoc(presentationDoc);\r\n      console.log('[PresentationService] Presentation deleted successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Set a presentation as live\r\n  async setLivePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Setting live presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        isLive: true,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Live presentation set successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error setting live presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a slide to the presentation (subcollection)\r\n  async addSlide(courseId, presentationId, slideData) {\r\n    try {\r\n      console.log('[PresentationService] Adding slide to subcollection:', { courseId, presentationId, slideData });\r\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\r\n      // Find max order\r\n      const slidesSnap = await getDocs(slidesCol);\r\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => Math.max(max, doc.data().order ?? 0), -1);\r\n      const newSlide = {\r\n        ...slideData,\r\n        order: (slideData.order !== undefined ? slideData.order : maxOrder + 1),\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n      };\r\n      const docRef = await addDoc(slidesCol, newSlide);\r\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\r\n      return { id: docRef.id, ...newSlide };\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update a specific slide (subcollection)\r\n  async updateSlide(courseId, presentationId, slideId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating slide in subcollection:', { courseId, presentationId, slideId, updates });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await updateDoc(slideDoc, { ...updates, updatedAt: Date.now() });\r\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a slide (subcollection)\r\n  async deleteSlide(courseId, presentationId, slideId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting slide from subcollection:', { courseId, presentationId, slideId });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await deleteDoc(slideDoc);\r\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a comment to a slide\r\n  async addComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      console.log('[PresentationService] Adding comment:', { courseId, presentationId, slideIndex, commentData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: commentData.username,\r\n        userId: commentData.userId,\r\n        text: commentData.text,\r\n        timestamp: serverTimestamp(),\r\n        likes: 0,\r\n        likedBy: [],\r\n        includedInGroups: []\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].comments.push(newComment);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a response to a slide (for poll slides)\r\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      console.log('[PresentationService] Adding response:', { courseId, presentationId, slideIndex, responseData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: responseData.username,\r\n        userId: responseData.userId,\r\n        answer: responseData.answer,\r\n        text: responseData.text,\r\n        timestamp: serverTimestamp(),\r\n        isCorrect: responseData.isCorrect || false\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].responses.push(newResponse);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Create a group for comments\r\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      console.log('[PresentationService] Creating group:', { courseId, presentationId, slideIndex, groupData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        label: groupData.label,\r\n        comments: groupData.comments || [],\r\n        likes: 0,\r\n        likedBy: [],\r\n        location: groupData.location || { x: 0, y: 0 },\r\n        createdAt: serverTimestamp()\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].groups.push(newGroup);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update current slide index for live presentations\r\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\r\n    try {\r\n      console.log('[PresentationService] Updating current slide index:', { courseId, presentationId, slideIndex });\r\n      await this.updatePresentation(courseId, presentationId, {\r\n        currentSlideIndex: slideIndex\r\n      });\r\n      console.log('[PresentationService] Current slide index updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating current slide index:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\r\n\r\n  // Add or update a student's response doc for a presentation\r\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...responseData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].responses.push(newResponse);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student response added:', { courseId, presentationId, slideIndex, userId, newResponse });\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's comment for a slide\r\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...commentData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].comments.push(newComment);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student comment added:', { courseId, presentationId, slideIndex, userId, newComment });\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's group for a slide\r\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...groupData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].groups.push(newGroup);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student group added:', { courseId, presentationId, slideIndex, userId, newGroup });\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a student's response doc\r\n  async getStudentResponse(courseId, presentationId, userId) {\r\n    try {\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      const docSnap = await getDoc(responseDocRef);\r\n      if (!docSnap.exists()) return null;\r\n      return docSnap.data();\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all student responses for a presentation (instructor only)\r\n  async getAllResponses(courseId, presentationId) {\r\n    try {\r\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\r\n      const snapshot = await getDocs(responsesCol);\r\n      const allResponses = snapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));\r\n      console.log('[PresentationService] All student responses fetched:', allResponses);\r\n      return allResponses;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting all responses:', err);\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new PresentationService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}