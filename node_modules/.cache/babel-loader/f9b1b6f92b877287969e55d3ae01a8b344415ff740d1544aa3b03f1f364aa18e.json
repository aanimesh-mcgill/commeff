{"ast":null,"code":"import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { getAuth } from 'firebase/auth';\nclass PresentationService {\n  // Get a reference to the presentations subcollection for a course\n  getPresentationsCollection(courseId) {\n    return collection(db, 'courses', courseId, 'presentations');\n  }\n\n  // Create a new presentation with unified structure\n  async createPresentation(courseId, title, ownerId) {\n    try {\n      console.log('[PresentationService] Creating presentation:', {\n        courseId,\n        title,\n        ownerId\n      });\n      // Fetch course to get instructorId\n      const courseDoc = await getDoc(doc(db, 'courses', courseId));\n      if (!courseDoc.exists()) throw new Error('Course not found');\n      const instructorId = courseDoc.data().instructorId;\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const docRef = await addDoc(presentationsCol, {\n        title,\n        ownerId,\n        instructorId,\n        // for consistency\n        courseId,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        currentSlideIndex: 0,\n        audienceMode: 'enrolledUsers',\n        // Default mode\n        isLive: false,\n        slides: [] // Initialize empty slides array\n      });\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\n      return docRef;\n    } catch (err) {\n      console.error('[PresentationService] Error creating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Get all presentations for a course\n  async getPresentations(courseId) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? {\n        uid: user.uid,\n        email: user.email\n      } : user);\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\n      const presentationsCol = this.getPresentationsCollection(courseId);\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\n      const snapshot = await getDocs(q);\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\n      const presentations = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] Presentations fetched:', presentations);\n      return presentations;\n    } catch (err) {\n      console.error('[PresentationService] Error fetching presentations:', err);\n      throw err;\n    }\n  }\n\n  // Get a single presentation with all slides\n  async getPresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Getting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      const snapshot = await getDoc(presentationDoc);\n      if (!snapshot.exists()) {\n        throw new Error('Presentation not found');\n      }\n      const presentation = {\n        id: snapshot.id,\n        ...snapshot.data()\n      };\n      console.log('[PresentationService] Presentation fetched:', presentation);\n      return presentation;\n    } catch (err) {\n      console.error('[PresentationService] Error getting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Update presentation metadata\n  async updatePresentation(courseId, presentationId, updates) {\n    try {\n      console.log('[PresentationService] Updating presentation:', {\n        courseId,\n        presentationId,\n        updates\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        ...updates,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Presentation updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating presentation:', err);\n      throw err;\n    }\n  }\n\n  // Delete a presentation\n  async deletePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Deleting presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await deleteDoc(presentationDoc);\n      console.log('[PresentationService] Presentation deleted successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error deleting presentation:', err);\n      throw err;\n    }\n  }\n\n  // Set a presentation as live\n  async setLivePresentation(courseId, presentationId) {\n    try {\n      console.log('[PresentationService] Setting live presentation:', {\n        courseId,\n        presentationId\n      });\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\n      await updateDoc(presentationDoc, {\n        isLive: true,\n        updatedAt: serverTimestamp()\n      });\n      console.log('[PresentationService] Live presentation set successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error setting live presentation:', err);\n      throw err;\n    }\n  }\n\n  // Add a slide to the presentation (subcollection)\n  async addSlide(courseId, presentationId, slideData) {\n    try {\n      console.log('[PresentationService] Adding slide to subcollection:', {\n        courseId,\n        presentationId,\n        slideData\n      });\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\n      // Find max order\n      const slidesSnap = await getDocs(slidesCol);\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => {\n        var _doc$data$order;\n        return Math.max(max, (_doc$data$order = doc.data().order) !== null && _doc$data$order !== void 0 ? _doc$data$order : 0);\n      }, -1);\n      const newSlide = {\n        ...slideData,\n        order: slideData.order !== undefined ? slideData.order : maxOrder + 1,\n        createdAt: Date.now(),\n        updatedAt: Date.now()\n      };\n      const docRef = await addDoc(slidesCol, newSlide);\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\n      return {\n        id: docRef.id,\n        ...newSlide\n      };\n    } catch (err) {\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Update a specific slide (subcollection)\n  async updateSlide(courseId, presentationId, slideId, updates) {\n    try {\n      console.log('[PresentationService] Updating slide in subcollection:', {\n        courseId,\n        presentationId,\n        slideId,\n        updates\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await updateDoc(slideDoc, {\n        ...updates,\n        updatedAt: Date.now()\n      });\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Delete a slide (subcollection)\n  async deleteSlide(courseId, presentationId, slideId) {\n    try {\n      console.log('[PresentationService] Deleting slide from subcollection:', {\n        courseId,\n        presentationId,\n        slideId\n      });\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\n      await deleteDoc(slideDoc);\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\n    } catch (err) {\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\n      throw err;\n    }\n  }\n\n  // Add a comment to a slide\n  async addComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      console.log('[PresentationService] Adding comment:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        commentData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: commentData.username,\n        userId: commentData.userId,\n        text: commentData.text,\n        timestamp: serverTimestamp(),\n        likes: 0,\n        likedBy: [],\n        includedInGroups: []\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].comments.push(newComment);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding comment:', err);\n      throw err;\n    }\n  }\n\n  // Add a response to a slide (for poll slides)\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      console.log('[PresentationService] Adding response:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        responseData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        username: responseData.username,\n        userId: responseData.userId,\n        answer: responseData.answer,\n        text: responseData.text,\n        timestamp: serverTimestamp(),\n        isCorrect: responseData.isCorrect || false\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].responses.push(newResponse);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding response:', err);\n      throw err;\n    }\n  }\n\n  // Create a group for comments\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      console.log('[PresentationService] Creating group:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        groupData\n      });\n      const presentation = await this.getPresentation(courseId, presentationId);\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\n        throw new Error('Invalid slide index');\n      }\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        label: groupData.label,\n        comments: groupData.comments || [],\n        likes: 0,\n        likedBy: [],\n        location: groupData.location || {\n          x: 0,\n          y: 0\n        },\n        createdAt: serverTimestamp()\n      };\n      const updatedSlides = [...presentation.slides];\n      updatedSlides[slideIndex].groups.push(newGroup);\n      await this.updatePresentation(courseId, presentationId, {\n        slides: updatedSlides\n      });\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error creating group:', err);\n      throw err;\n    }\n  }\n\n  // Update current slide index for live presentations\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\n    try {\n      console.log('[PresentationService] Updating current slide index:', {\n        courseId,\n        presentationId,\n        slideIndex\n      });\n      await this.updatePresentation(courseId, presentationId, {\n        currentSlideIndex: slideIndex\n      });\n      console.log('[PresentationService] Current slide index updated successfully');\n    } catch (err) {\n      console.error('[PresentationService] Error updating current slide index:', err);\n      throw err;\n    }\n  }\n\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\n\n  // Add or update a student's response doc for a presentation\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\n      const newResponse = {\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...responseData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].responses.push(newResponse);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student response added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newResponse\n      });\n      return newResponse;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student response:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's comment for a slide\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\n      const newComment = {\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...commentData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].comments.push(newComment);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student comment added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newComment\n      });\n      return newComment;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student comment:', err);\n      throw err;\n    }\n  }\n\n  // Add or update a student's group for a slide\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n      if (!user) throw new Error('Not authenticated');\n      const userId = user.uid;\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      let docSnap = await getDoc(responseDocRef);\n      let data = docSnap.exists() ? docSnap.data() : {\n        slides: []\n      };\n      // Ensure slides array is correct length\n      while (data.slides.length <= slideIndex) data.slides.push({\n        comments: [],\n        responses: [],\n        groups: []\n      });\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\n      const newGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...groupData,\n        timestamp: serverTimestamp()\n      };\n      data.slides[slideIndex].groups.push(newGroup);\n      await setDoc(responseDocRef, data);\n      console.log('[PresentationService] Student group added:', {\n        courseId,\n        presentationId,\n        slideIndex,\n        userId,\n        newGroup\n      });\n      return newGroup;\n    } catch (err) {\n      console.error('[PresentationService] Error adding student group:', err);\n      throw err;\n    }\n  }\n\n  // Get a student's response doc\n  async getStudentResponse(courseId, presentationId, userId) {\n    try {\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\n      const docSnap = await getDoc(responseDocRef);\n      if (!docSnap.exists()) return null;\n      return docSnap.data();\n    } catch (err) {\n      console.error('[PresentationService] Error getting student response:', err);\n      throw err;\n    }\n  }\n\n  // Get all student responses for a presentation (instructor only)\n  async getAllResponses(courseId, presentationId) {\n    try {\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\n      const snapshot = await getDocs(responsesCol);\n      const allResponses = snapshot.docs.map(doc => ({\n        userId: doc.id,\n        ...doc.data()\n      }));\n      console.log('[PresentationService] All student responses fetched:', allResponses);\n      return allResponses;\n    } catch (err) {\n      console.error('[PresentationService] Error getting all responses:', err);\n      throw err;\n    }\n  }\n}\nexport default new PresentationService();","map":{"version":3,"names":["collection","addDoc","getDocs","query","orderBy","serverTimestamp","doc","deleteDoc","updateDoc","getDoc","setDoc","db","getAuth","PresentationService","getPresentationsCollection","courseId","createPresentation","title","ownerId","console","log","courseDoc","exists","Error","instructorId","data","presentationsCol","docRef","createdAt","updatedAt","currentSlideIndex","audienceMode","isLive","slides","id","err","error","getPresentations","auth","user","currentUser","uid","email","q","snapshot","size","presentations","docs","map","getPresentation","presentationId","presentationDoc","presentation","updatePresentation","updates","deletePresentation","setLivePresentation","addSlide","slideData","slidesCol","slidesSnap","maxOrder","reduce","max","_doc$data$order","Math","order","newSlide","undefined","Date","now","updateSlide","slideId","slideDoc","deleteSlide","addComment","slideIndex","commentData","length","newComment","random","toString","substr","username","userId","text","timestamp","likes","likedBy","includedInGroups","updatedSlides","comments","push","addResponse","responseData","newResponse","answer","isCorrect","responses","createGroup","groupData","newGroup","label","location","x","y","groups","updateCurrentSlideIndex","addStudentResponse","responseDocRef","docSnap","addStudentComment","addStudentGroup","getStudentResponse","getAllResponses","responsesCol","allResponses"],"sources":["C:/Users/aanime/commeff3/src/services/PresentationService.js"],"sourcesContent":["import { collection, addDoc, getDocs, query, orderBy, serverTimestamp, doc, deleteDoc, updateDoc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { db } from '../firebase/config';\r\nimport { getAuth } from 'firebase/auth';\r\n\r\nclass PresentationService {\r\n  // Get a reference to the presentations subcollection for a course\r\n  getPresentationsCollection(courseId) {\r\n    return collection(db, 'courses', courseId, 'presentations');\r\n  }\r\n\r\n  // Create a new presentation with unified structure\r\n  async createPresentation(courseId, title, ownerId) {\r\n    try {\r\n      console.log('[PresentationService] Creating presentation:', { courseId, title, ownerId });\r\n      // Fetch course to get instructorId\r\n      const courseDoc = await getDoc(doc(db, 'courses', courseId));\r\n      if (!courseDoc.exists()) throw new Error('Course not found');\r\n      const instructorId = courseDoc.data().instructorId;\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const docRef = await addDoc(presentationsCol, {\r\n        title,\r\n        ownerId,\r\n        instructorId, // for consistency\r\n        courseId,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp(),\r\n        currentSlideIndex: 0,\r\n        audienceMode: 'enrolledUsers', // Default mode\r\n        isLive: false,\r\n        slides: [] // Initialize empty slides array\r\n      });\r\n      console.log('[PresentationService] Presentation created with ID:', docRef.id);\r\n      return docRef;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all presentations for a course\r\n  async getPresentations(courseId) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      console.log('[PresentationService][DEBUG] getPresentations called. Auth currentUser:', user ? { uid: user.uid, email: user.email } : user);\r\n      console.log('[PresentationService] Fetching presentations for course:', courseId);\r\n      const presentationsCol = this.getPresentationsCollection(courseId);\r\n      const q = query(presentationsCol, orderBy('createdAt', 'asc'));\r\n      console.log('[PresentationService][DEBUG] About to call getDocs.');\r\n      const snapshot = await getDocs(q);\r\n      console.log('[PresentationService][DEBUG] getDocs completed. Snapshot size:', snapshot.size);\r\n      const presentations = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      console.log('[PresentationService] Presentations fetched:', presentations);\r\n      return presentations;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error fetching presentations:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a single presentation with all slides\r\n  async getPresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Getting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      const snapshot = await getDoc(presentationDoc);\r\n      \r\n      if (!snapshot.exists()) {\r\n        throw new Error('Presentation not found');\r\n      }\r\n      \r\n      const presentation = {\r\n        id: snapshot.id,\r\n        ...snapshot.data()\r\n      };\r\n      \r\n      console.log('[PresentationService] Presentation fetched:', presentation);\r\n      return presentation;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update presentation metadata\r\n  async updatePresentation(courseId, presentationId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating presentation:', { courseId, presentationId, updates });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        ...updates,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Presentation updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a presentation\r\n  async deletePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await deleteDoc(presentationDoc);\r\n      console.log('[PresentationService] Presentation deleted successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Set a presentation as live\r\n  async setLivePresentation(courseId, presentationId) {\r\n    try {\r\n      console.log('[PresentationService] Setting live presentation:', { courseId, presentationId });\r\n      const presentationDoc = doc(db, 'courses', courseId, 'presentations', presentationId);\r\n      await updateDoc(presentationDoc, {\r\n        isLive: true,\r\n        updatedAt: serverTimestamp()\r\n      });\r\n      console.log('[PresentationService] Live presentation set successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error setting live presentation:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a slide to the presentation (subcollection)\r\n  async addSlide(courseId, presentationId, slideData) {\r\n    try {\r\n      console.log('[PresentationService] Adding slide to subcollection:', { courseId, presentationId, slideData });\r\n      const slidesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'slides');\r\n      // Find max order\r\n      const slidesSnap = await getDocs(slidesCol);\r\n      const maxOrder = slidesSnap.docs.reduce((max, doc) => Math.max(max, doc.data().order ?? 0), -1);\r\n      const newSlide = {\r\n        ...slideData,\r\n        order: (slideData.order !== undefined ? slideData.order : maxOrder + 1),\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n      };\r\n      const docRef = await addDoc(slidesCol, newSlide);\r\n      console.log('[PresentationService] Slide added to subcollection:', docRef.id);\r\n      return { id: docRef.id, ...newSlide };\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding slide to subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update a specific slide (subcollection)\r\n  async updateSlide(courseId, presentationId, slideId, updates) {\r\n    try {\r\n      console.log('[PresentationService] Updating slide in subcollection:', { courseId, presentationId, slideId, updates });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await updateDoc(slideDoc, { ...updates, updatedAt: Date.now() });\r\n      console.log('[PresentationService] Slide updated in subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating slide in subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Delete a slide (subcollection)\r\n  async deleteSlide(courseId, presentationId, slideId) {\r\n    try {\r\n      console.log('[PresentationService] Deleting slide from subcollection:', { courseId, presentationId, slideId });\r\n      const slideDoc = doc(db, 'courses', courseId, 'presentations', presentationId, 'slides', slideId);\r\n      await deleteDoc(slideDoc);\r\n      console.log('[PresentationService] Slide deleted from subcollection:', slideId);\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error deleting slide from subcollection:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a comment to a slide\r\n  async addComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      console.log('[PresentationService] Adding comment:', { courseId, presentationId, slideIndex, commentData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: commentData.username,\r\n        userId: commentData.userId,\r\n        text: commentData.text,\r\n        timestamp: serverTimestamp(),\r\n        likes: 0,\r\n        likedBy: [],\r\n        includedInGroups: []\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].comments.push(newComment);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Comment added successfully:', newComment.id);\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add a response to a slide (for poll slides)\r\n  async addResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      console.log('[PresentationService] Adding response:', { courseId, presentationId, slideIndex, responseData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        username: responseData.username,\r\n        userId: responseData.userId,\r\n        answer: responseData.answer,\r\n        text: responseData.text,\r\n        timestamp: serverTimestamp(),\r\n        isCorrect: responseData.isCorrect || false\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].responses.push(newResponse);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Response added successfully:', newResponse.id);\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Create a group for comments\r\n  async createGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      console.log('[PresentationService] Creating group:', { courseId, presentationId, slideIndex, groupData });\r\n      const presentation = await this.getPresentation(courseId, presentationId);\r\n      \r\n      if (slideIndex < 0 || slideIndex >= presentation.slides.length) {\r\n        throw new Error('Invalid slide index');\r\n      }\r\n      \r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        label: groupData.label,\r\n        comments: groupData.comments || [],\r\n        likes: 0,\r\n        likedBy: [],\r\n        location: groupData.location || { x: 0, y: 0 },\r\n        createdAt: serverTimestamp()\r\n      };\r\n      \r\n      const updatedSlides = [...presentation.slides];\r\n      updatedSlides[slideIndex].groups.push(newGroup);\r\n      \r\n      await this.updatePresentation(courseId, presentationId, {\r\n        slides: updatedSlides\r\n      });\r\n      \r\n      console.log('[PresentationService] Group created successfully:', newGroup.id);\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error creating group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Update current slide index for live presentations\r\n  async updateCurrentSlideIndex(courseId, presentationId, slideIndex) {\r\n    try {\r\n      console.log('[PresentationService] Updating current slide index:', { courseId, presentationId, slideIndex });\r\n      await this.updatePresentation(courseId, presentationId, {\r\n        currentSlideIndex: slideIndex\r\n      });\r\n      console.log('[PresentationService] Current slide index updated successfully');\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error updating current slide index:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // --- STUDENT RESPONSE SUBCOLLECTION METHODS ---\r\n\r\n  // Add or update a student's response doc for a presentation\r\n  async addStudentResponse(courseId, presentationId, slideIndex, responseData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].responses) data.slides[slideIndex].responses = [];\r\n      const newResponse = {\r\n        id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...responseData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].responses.push(newResponse);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student response added:', { courseId, presentationId, slideIndex, userId, newResponse });\r\n      return newResponse;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's comment for a slide\r\n  async addStudentComment(courseId, presentationId, slideIndex, commentData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].comments) data.slides[slideIndex].comments = [];\r\n      const newComment = {\r\n        id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...commentData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].comments.push(newComment);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student comment added:', { courseId, presentationId, slideIndex, userId, newComment });\r\n      return newComment;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student comment:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Add or update a student's group for a slide\r\n  async addStudentGroup(courseId, presentationId, slideIndex, groupData) {\r\n    try {\r\n      const auth = getAuth();\r\n      const user = auth.currentUser;\r\n      if (!user) throw new Error('Not authenticated');\r\n      const userId = user.uid;\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      let docSnap = await getDoc(responseDocRef);\r\n      let data = docSnap.exists() ? docSnap.data() : { slides: [] };\r\n      // Ensure slides array is correct length\r\n      while (data.slides.length <= slideIndex) data.slides.push({ comments: [], responses: [], groups: [] });\r\n      if (!data.slides[slideIndex].groups) data.slides[slideIndex].groups = [];\r\n      const newGroup = {\r\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        ...groupData,\r\n        timestamp: serverTimestamp(),\r\n      };\r\n      data.slides[slideIndex].groups.push(newGroup);\r\n      await setDoc(responseDocRef, data);\r\n      console.log('[PresentationService] Student group added:', { courseId, presentationId, slideIndex, userId, newGroup });\r\n      return newGroup;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error adding student group:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get a student's response doc\r\n  async getStudentResponse(courseId, presentationId, userId) {\r\n    try {\r\n      const responseDocRef = doc(db, 'courses', courseId, 'presentations', presentationId, 'responses', userId);\r\n      const docSnap = await getDoc(responseDocRef);\r\n      if (!docSnap.exists()) return null;\r\n      return docSnap.data();\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting student response:', err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get all student responses for a presentation (instructor only)\r\n  async getAllResponses(courseId, presentationId) {\r\n    try {\r\n      const responsesCol = collection(db, 'courses', courseId, 'presentations', presentationId, 'responses');\r\n      const snapshot = await getDocs(responsesCol);\r\n      const allResponses = snapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));\r\n      console.log('[PresentationService] All student responses fetched:', allResponses);\r\n      return allResponses;\r\n    } catch (err) {\r\n      console.error('[PresentationService] Error getting all responses:', err);\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new PresentationService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}